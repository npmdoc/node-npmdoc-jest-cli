<div class="apidocDiv">
<style>
/*csslint
*/
.apidocDiv {
    background: #fff;
    font-family: Arial, Helvetica, sans-serif;
}
.apidocDiv a[href] {
    color: #33f;
    font-weight: bold;
    text-decoration: none;
}
.apidocDiv a[href]:hover {
    text-decoration: underline;
}
.apidocCodeCommentSpan {
    background: #bbf;
    color: #000;
    display: block;
}
.apidocCodeKeywordSpan {
    color: #d00;
    font-weight: bold;
}
.apidocCodePre {
    background: #eef;
    border: 1px solid;
    color: #777;
    padding: 5px;
    white-space: pre-wrap;
}
.apidocFooterDiv {
    margin-top: 20px;
    text-align: center;
}
.apidocModuleLi {
    margin-top: 10px;
}
.apidocSectionDiv {
    border-top: 1px solid;
    margin-top: 20px;
}
.apidocSignatureSpan {
    color: #777;
    font-weight: bold;
}
</style>
<h1>api documentation for
    <a

        href="http://facebook.github.io/jest/"

    >jest-cli (v19.0.2)</a>
</h1>
<h4>Painless JavaScript Testing.</h4>
<div class="apidocSectionDiv"><a
    href="#apidoc.tableOfContents"
    id="apidoc.tableOfContents"
><h1>table of contents</h1></a><ol>

    <li class="apidocModuleLi"><a href="#apidoc.module.jest-cli">module jest-cli</a><ol>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.jest-cli.SearchSource">
            function <span class="apidocSignatureSpan">jest-cli.</span>SearchSource
            <span class="apidocSignatureSpan">( hasteMap, config, options)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.jest-cli.TestRunner">
            function <span class="apidocSignatureSpan">jest-cli.</span>TestRunner
            <span class="apidocSignatureSpan">( hasteContext, config, options, startRun)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.jest-cli.TestWatcher">
            function <span class="apidocSignatureSpan">jest-cli.</span>TestWatcher
            <span class="apidocSignatureSpan">(_ref)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.jest-cli.getVersion">
            function <span class="apidocSignatureSpan">jest-cli.</span>getVersion
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.jest-cli.run">
            function <span class="apidocSignatureSpan">jest-cli.</span>run
            <span class="apidocSignatureSpan">(argv, root)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.jest-cli.runCLI">
            function <span class="apidocSignatureSpan">jest-cli.</span>runCLI
            <span class="apidocSignatureSpan">( argv, root, onComplete)</span>
            </a>

        </li>

    </ol></li>

</ol></div>

<div class="apidocSectionDiv">
<h1><a href="#apidoc.module.jest-cli" id="apidoc.module.jest-cli">module jest-cli</a></h1>


    <h2>
        <a href="#apidoc.element.jest-cli.SearchSource" id="apidoc.element.jest-cli.SearchSource">
        function <span class="apidocSignatureSpan">jest-cli.</span>SearchSource
        <span class="apidocSignatureSpan">( hasteMap, config, options)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">class SearchSource {












constructor( hasteMap, config, options)
{
  this._hasteContext = hasteMap;
  this._config = config;
  this._options = options || {
    skipNodeResolution: false };


  this._rootPattern =
  new RegExp(config.roots.map(
  dir =&#x3e; escapePathForRegex(dir)).
  join(&#x27;|&#x27;));

  const ignorePattern = config.testPathIgnorePatterns;
  this._testIgnorePattern =
  ignorePattern.length ? new RegExp(ignorePattern.join(&#x27;|&#x27;)) : null;

  this._testPathCases = {
    roots: path =&#x3e; this._rootPattern.test(path),
    testMatch: globsToMatcher(config.testMatch),
    testPathIgnorePatterns: path =&#x3e;
    !this._testIgnorePattern ||
    !this._testIgnorePattern.test(path),

    testRegex: regexToMatcher(config.testRegex) };

}

_filterTestPathsWithStats(
allPaths,
testPathPattern)
{
  const data = {
    paths: [],
    stats: {},
    total: allPaths.length };


  const testCases = Object.assign({}, this._testPathCases);
  if (testPathPattern) {
    const regex = new RegExp(testPathPattern, &#x27;i&#x27;);
    testCases.testPathPattern = path =&#x3e; regex.test(path);
  }

  data.paths = allPaths.filter(path =&#x3e; {
    return Object.keys(testCases).reduce((flag, key) =&#x3e; {
      if (testCases[key](path)) {
        data.stats[key] = ++data.stats[key] || 1;
        return flag &#x26;&#x26; true;
      }
      data.stats[key] = data.stats[key] || 0;
      return false;
    }, true);
  });

  return data;
}

_getAllTestPaths(
testPathPattern)
{
  return this._filterTestPathsWithStats(
  this._hasteContext.hasteFS.getAllFiles(),
  testPathPattern);

}

isTestFilePath(path) {
  return Object.keys(this._testPathCases).every(key =&#x3e;
  this._testPathCases[key](path));

}

findMatchingTests(
testPathPattern)
{
  return this._getAllTestPaths(testPathPattern);
}

findRelatedTests(allPaths) {
  const dependencyResolver = new DependencyResolver(
  this._hasteContext.resolver,
  this._hasteContext.hasteFS);

  return {
    paths: dependencyResolver.resolveInverse(
    allPaths,
    this.isTestFilePath.bind(this),
    {
      skipNodeResolution: this._options.skipNodeResolution }) };



}

findRelatedTestsFromPattern(
paths)
{
  if (Array.isArray(paths) &#x26;&#x26; paths.length) {
    const resolvedPaths = paths.map(p =&#x3e; path.resolve(process.cwd(), p));
    return this.findRelatedTests(new Set(resolvedPaths));
  }
  return { paths: [] };
}

findChangedTests(options) {
  return Promise.all(this._config.roots.map(determineSCM)).
  then(repos =&#x3e; {
    if (!repos.every((_ref) =&#x3e; {var _ref2 = _slicedToArray(_ref, 2);let gitRepo = _ref2[0],hgRepo = _ref2[1];return gitRepo || hgRepo
;})) {
      return {
        noSCM: true,
        paths: [] };

    }
    return Promise.all(Array.from(repos).map((_ref3) =&#x3e; {var _ref4 = _slicedToArray(_ref3, 2);let gitRepo = _ref4[0],hgRepo = _ref4
[1];
      return gitRepo ?
      git.findChangedFiles(gitRepo, options) :
      hg.findChangedFiles(hgRepo, options);
    })).then(changedPathSets =&#x3e; this.findRelatedTests(
    new Set(Array.prototype.concat.apply([], changedPathSets))));

  });
}

getNoTestsFoundMessage(
patternInfo,
config,
data)
{
  if (patternInfo.onlyChanged) {
    return (
      chalk.bold(
      &#x27;No tests found related to files changed since last commit.\n&#x27;) +

      chalk.dim(
      patternInfo.watch ?
      &#x27;Press `a` to run all tests, or run Jest with `--watchAll`.&#x27; :
      &#x27;Run Jest without `-o` to run all tests.&#x27;));


  }

  const testPathPattern = SearchSource.getTestPathPattern(patternInfo);
  const stats = data.stats || {};
  const statsMessage = Object.keys(stats).map(key =&#x3e; {
    const value = key === &#x27;testPathPattern&#x27; ? testPathPattern : config[key];
    if (value) {
      const matches = pluralize(&#x27;match&#x27;, stats[key], &#x27;es&#x27;);
      return `  ${key}: ${chalk.yellow(value)} - ${matches}`;
    }
    return null;
  }).filter(line =&#x3e; line).join(&#x27;\n&#x27;);

  return (
    chalk.bold(&#x27;No tests found&#x27;) + &#x27;\n&#x27; + (
    data.total ?
    `  ${pluralize(&#x27;file&#x27;, data.total || 0, &#x27;s&#x27;)} checked.\n` +
    statsMessage :
    `No files found in ${config.rootDir}.\n` +
    `Make sure Jest&#x27;s configuration does not exclude this directory.\ ...</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.jest-cli.TestRunner" id="apidoc.element.jest-cli.TestRunner">
        function <span class="apidocSignatureSpan">jest-cli.</span>TestRunner
        <span class="apidocSignatureSpan">( hasteContext, config, options, startRun)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">class TestRunner {







constructor( hasteContext, config, options, startRun)
{
  this._config = config;
  this._dispatcher = new ReporterDispatcher(
  hasteContext.hasteFS,
  options.getTestSummary);

  this._hasteContext = hasteContext;
  this._options = options;
  this._startRun = startRun;
  this._setupReporters();

  // Map from testFilePath -&#x3e; time it takes to run the test. Used to
  // optimally schedule bigger test runs.
  this._testPerformanceCache = {};
}

addReporter(reporter) {
  this._dispatcher.register(reporter);
}

removeReporter(ReporterClass) {
  this._dispatcher.unregister(ReporterClass);
}

_getTestPerformanceCachePath() {
  const config = this._config;
  return getCacheFilePath(config.cacheDirectory, &#x27;perf-cache-&#x27; + config.name);
}

_sortTests(testPaths) {
  // When running more tests than we have workers available, sort the tests
  // by size - big test files usually take longer to complete, so we run
  // them first in an effort to minimize worker idle time at the end of a
  // long test run.
  //
  // After a test run we store the time it took to run a test and on
  // subsequent runs we use that to run the slowest tests first, yielding the
  // fastest results.
  try {
    if (this._config.cache) {
      this._testPerformanceCache = JSON.parse(fs.readFileSync(
      this._getTestPerformanceCachePath(),
      &#x27;utf8&#x27;));

    } else {
      this._testPerformanceCache = {};
    }
  } catch (e) {
    this._testPerformanceCache = {};
  }

  const cache = this._testPerformanceCache;
  const timings = [];
  const stats = {};
  const getFileSize = filePath =&#x3e;
  stats[filePath] || (stats[filePath] = fs.statSync(filePath).size);
  const getTestRunTime = filePath =&#x3e; {
    if (cache[filePath]) {
      return cache[filePath][0] === FAIL ? Infinity : cache[filePath][1];
    }
    return null;
  };

  testPaths = testPaths.
  sort((pathA, pathB) =&#x3e; {
    const timeA = getTestRunTime(pathA);
    const timeB = getTestRunTime(pathB);
    if (timeA != null &#x26;&#x26; timeB != null) {
      return timeA &#x3c; timeB ? 1 : -1;
    }
    return getFileSize(pathA) &#x3c; getFileSize(pathB) ? 1 : -1;
  });

  testPaths.forEach(filePath =&#x3e; {
    const timing = cache[filePath] &#x26;&#x26; cache[filePath][1];
    if (timing) {
      timings.push(timing);
    }
  });

  return { testPaths, timings };
}

_cacheTestResults(aggregatedResults) {
  const cache = this._testPerformanceCache;
  aggregatedResults.testResults.forEach(test =&#x3e; {
    if (test &#x26;&#x26; !test.skipped) {
      const perf = test.perfStats;
      cache[test.testFilePath] = [
      test.numFailingTests ? FAIL : SUCCESS,
      perf.end - perf.start || 0];

    }
  });
  fs.writeFileSync(
  this._getTestPerformanceCachePath(),
  JSON.stringify(cache));

}

runTests(paths, watcher) {
  const config = this._config;var _sortTests =
  this._sortTests(paths);const testPaths = _sortTests.testPaths,timings = _sortTests.timings;
  const aggregatedResults = createAggregatedResults(testPaths.length);
  const estimatedTime =
  Math.ceil(getEstimatedTime(timings, this._options.maxWorkers) / 1000);

  const onResult = (testPath, testResult) =&#x3e; {
    if (watcher.isInterrupted()) {
      return;
    }
    if (testResult.testResults.length === 0) {
      const message = &#x27;Your test suite must contain at least one test.&#x27;;
      onFailure(testPath, {
        message,
        stack: new Error(message).stack });

      return;
    }
    addResult(aggregatedResults, testResult);
    this._dispatcher.onTestResult(
    config,
    testResult,
    aggregatedResults);

    this._bailIfNeeded(aggregatedResults, watcher);
  };

  const onFailure = (testPath, error) =&#x3e; {
    if (watcher.isInterrupted()) {
      return;
    }
    const testResult = buildFailureTestResult(testPath, error);
    testResult.failureMessage = formatExecError(testResult, config, testPath);
    addResult(aggregatedResults, testResult);
    this._dispatcher.onTestResult(
    config,
    testResult,
    aggregatedResults);

  };

  // Run in band if we only have one test or one worker available.
  // If we are confident from previous runs that the ...</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.jest-cli.TestWatcher" id="apidoc.element.jest-cli.TestWatcher">
        function <span class="apidocSignatureSpan">jest-cli.</span>TestWatcher
        <span class="apidocSignatureSpan">(_ref)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">class TestWatcher extends EventEmitter {



constructor(_ref) {let isWatchMode = _ref.isWatchMode;
  super();
  this.state = { interrupted: false };
  this._isWatchMode = isWatchMode;
}

setState(state) {
  Object.assign(this.state, state);
  this.emit(&#x27;change&#x27;, this.state);
}

isInterrupted() {
  return this.state.interrupted;
}

isWatchMode() {
  return this._isWatchMode;
}}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.jest-cli.getVersion" id="apidoc.element.jest-cli.getVersion">
        function <span class="apidocSignatureSpan">jest-cli.</span>getVersion
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">() =&#x3e; VERSION</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.jest-cli.run" id="apidoc.element.jest-cli.run">
        function <span class="apidocSignatureSpan">jest-cli.</span>run
        <span class="apidocSignatureSpan">(argv, root)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function run(argv, root) {
  argv = yargs(argv || process.argv.slice(2)).
  usage(args.usage).
  help().
  alias(&#x27;help&#x27;, &#x27;h&#x27;).
  options(args.options).
  check(args.check).
  argv;

  validateCLIOptions(argv, args.options);

  if (argv.help) {
    yargs.showHelp();
    process.on(&#x27;exit&#x27;, () =&#x3e; process.exit(1));
    return;
  }

  if (!root) {
    root = getPackageRoot();
  }

  getJest(root).runCLI(argv, root, result =&#x3e; {
    const code = !result || result.success ? 0 : 1;
    process.on(&#x27;exit&#x27;, () =&#x3e; process.exit(code));
    if (argv &#x26;&#x26; argv.forceExit) {
      process.exit(code);
    }
  });
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.jest-cli.runCLI" id="apidoc.element.jest-cli.runCLI">
        function <span class="apidocSignatureSpan">jest-cli.</span>runCLI
        <span class="apidocSignatureSpan">( argv, root, onComplete)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">( argv, root, onComplete) =&#x3e;
{
  const pipe = argv.json ? process.stderr : process.stdout;
  argv = argv || {};
  if (argv.version) {
    pipe.write(`v${VERSION}\n`);
    onComplete &#x26;&#x26; onComplete();
    return;
  }

  readConfig(argv, root).
  then((_ref) =&#x3e;





  {let config = _ref.config,hasDeprecationWarnings = _ref.hasDeprecationWarnings;
    if (argv.debug) {
      logDebugMessages(config, pipe);
    }

    createDirectory(config.cacheDirectory);
    const jestHasteMap = Runtime.createHasteMap(config, {
      console: new Console(pipe, pipe),
      maxWorkers: getMaxWorkers(argv),
      resetCache: !config.cache,
      watch: config.watch });


    return jestHasteMap.build().then(
    hasteMap =&#x3e; createHasteContext(config, hasteMap),
    error =&#x3e; {
      throw error;
    }).

    then(hasteContext =&#x3e; {
      if (argv.watch || argv.watchAll) {
        return watch(
        config,
        pipe,
        argv,
        jestHasteMap,
        hasteContext,
        hasDeprecationWarnings);

      } else {
        const startRun = () =&#x3e; {
          preRunMessage.print(pipe);
          const testWatcher = new TestWatcher({ isWatchMode: false });
          return runJest(
          hasteContext,
          config,
          argv,
          pipe,
          testWatcher,
          startRun,
          onComplete);

        };
        return startRun();
      }
    });
  }).
  catch(error =&#x3e; {
    clearLine(process.stderr);
    clearLine(process.stdout);
    console.error(chalk.red(error.stack));
    process.exit(1);
  });
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>


</div>

<div class="apidocFooterDiv">
    [ this document was created with
    <a href="https://github.com/kaizhu256/node-utility2" target="_blank">utility2</a>
    ]
</div>
</div>
